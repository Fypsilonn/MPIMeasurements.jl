export DAQParams

mutable struct DAQParams
  decimation::Int64 -> RP specific

  # Done
  dfBaseFrequency::Float64 -> specific to Sequence
  dfDivider::Vector{Int64} -> specific to Sequence
  dfFreq::Vector{Float64} -> specific to Sequence
  dfStrength::Vector{Float64} -> specific to Sequence
  dfPhase::Vector{Float64} -> specific to Sequence
  dfCycle::Float64 -> specific to Sequence
  dfWaveform::String -> specific to Sequence
  # /Done

  jumpSharpness::Float64 -> RP specific
  rxBandwidth::Float64 -> DAQ specific
  acqNumPeriodsPerFrame::Int64 -> specific to Sequence
  numSampPerPeriod::Int64 -> specific to Sequence
  rxNumSamplingPoints::Int64 -> specific to Sequence
  acqNumFrames::Int64 -> specific to Protocol
  acqNumBGFrames::Int64 -> specific to Protocol
  acqFramePeriod::Float64 -> specific to Sequence
  acqNumAverages::Int64 -> specific to Protocol
  acqNumFrameAverages::Int64 -> specific to Protocol
  acqNumSubperiods::Int64 -> specific to Sequence
  acqNumPeriodsPerPatch::Int64 -> specific to Protocol or Sequence
  sinLUT::Matrix{Float64} -> specific to Control
  cosLUT::Matrix{Float64} -> specific to Control
  acqNumFFChannels::Int64 -> specific to Sequence
  acqFFValues::Matrix{Float64} -> RP specific
  acqEnableSequence::Matrix{Bool} -> RP specific but should be in Sequence
  calibIntToVolt::Matrix{Float64} -> RP specific, can be removed by resolving issue #10 in DAQServer
  calibRefToField::Vector{Float64} -> scanner specific
  calibFieldToVolt::Vector{Float64} -> scanner specific
  calibFFCurrentToVolt::Vector{Float64} -> scanner specific
  currTx::Matrix{ComplexF64} -> specific to Control
  controlPause::Float64 -> specific to Sequence
  controlLoopAmplitudeAccuracy::Float64 -> specific to Sequence
  controlLoopPhaseAccuracy::Float64 -> specific to Sequence
  correctCrossCoupling::Bool -> specific to Sequence
  rxChanIdx::Vector{Int64} -> specific to Sequence
  refChanIdx::Vector{Int64} -> specific to Sequence
  dfChanIdx::Vector{Int64} -> specific to Sequence
  txLimitVolt::Vector{Float64} -> specific to Scanner
  txOffsetVolt::Vector{Float64} -> specific to Sequence
  controlPhase::Bool -> specific to Sequence
  acqFFSequence::String -> specific to Sequence, but not yet there
  ffRampUpTime::Float64 -> specific to Sequence, but not yet there
  ffRampUpFraction::Float64 -> specific to Sequence, but not yet there
  triggerMode::String -> RP specific
  passPDMToFastDAC::Vector{Bool} -> RP specific
end

function calcDFFreq(baseFreq::Float64, divider::Vector{Int64})
  return baseFreq ./ divider
end

function DAQParams(@nospecialize params_)

  params = deepcopy(params_) # We do not want to change the user parameter!

  D = length(params["dfDivider"])
  #dfFreq = params["dfBaseFrequency"] ./ params["dfDivider"]
  dfFreq = calcDFFreq(params["dfBaseFrequency"],params["dfDivider"])
  dfCycle = lcm(params["dfDivider"]) / params["dfBaseFrequency"]

  if !all(isinteger, params["dfDivider"] / params["decimation"])
    warn("$(params["dfDivider"]) cannot be divided by $(params["decimation"])")
  end
  numSampPerPeriod = round(Int, lcm(params["dfDivider"]) / params["decimation"])

  rxBandwidth = params["dfBaseFrequency"] / params["decimation"] / 2

  sinLUT, cosLUT = initLUT(numSampPerPeriod, D, dfCycle, dfFreq)

  if !haskey(params, "currTx")
    params["currTx"] = convert(Matrix{ComplexF64}, diagm(params["txLimitVolt"] / 10))
  end

  if !haskey(params, "txOffsetVolt")
    params["txOffsetVolt"] = zeros(length(params["txLimitVolt"]))
  end

  if !haskey(params, "controlPhase")
    params["controlPhase"] = true
  end

  if !haskey(params, "correctCrossCoupling")
    params["correctCrossCoupling"] = false
  end

  if !haskey(params, "dfWaveform")
    params["dfWaveform"] = "SINE"
  end  

  if !haskey(params,"acqFFSequence")
    params["acqFFSequence"] = "None"
  end
  if params["acqFFSequence"] != ""

    s = Sequence(params["acqFFSequence"])

    params["acqFFValues"] = s.values 
    params["acqNumFFChannels"] = size(params["acqFFValues"],1)
    params["acqNumPeriodsPerFrame"] = acqNumPeriodsPerFrame(s)
    params["acqNumPeriodsPerPatch"] = acqNumPeriodsPerPatch(s)
    params["acqEnableSequence"] = s.enable
  else
    params["acqFFValues"] = zeros(0,0)
    params["acqNumFFChannels"] = 1
    params["acqNumPeriodsPerFrame"] = 1
    params["acqEnableSequence"] = zeros(Bool,0,0)
  end

  acqFramePeriod = dfCycle * params["acqNumPeriodsPerFrame"]

  if !haskey(params,"calibFFCurrentToVolt")
    params["calibFFCurrentToVolt"] = [0.0]
  end


  if !haskey(params,"acqNumSubperiods")
    params["acqNumSubperiods"] = 1
  end

  if !haskey(params,"acqNumPeriodsPerPatch")
    params["acqNumPeriodsPerPatch"] = 1
  end

  if !haskey(params,"ffRampUpTime")
    params["ffRampUpTime"] = 0.4
  end

  if !haskey(params,"ffRampUpFraction")
    params["ffRampUpFraction"] = 0.8
  end

  if !haskey(params,"acqNumFrameAverages")
    params["acqNumFrameAverages"] = 1
  end

  if !haskey(params,"acqNumBGFrames")
    params["acqNumBGFrames"] = 1
  end

  if !haskey(params,"triggerMode")
    params["triggerMode"] = "EXTERNAL"
  end

  if !haskey(params,"jumpSharpness")
    params["jumpSharpness"] = 0.0
  end

  if !haskey(params,"passPDMToFastDAC")
    params["passPDMToFastDAC"] = zeros(Bool,10) # how many RP have we???
  end

  params = DAQParams(
    params["decimation"],
    params["dfBaseFrequency"],
    params["dfDivider"],
    dfFreq,
    params["dfStrength"],
    params["dfPhase"],
    dfCycle,
    params["dfWaveform"],
    params["jumpSharpness"],
    rxBandwidth,
    params["acqNumPeriodsPerFrame"],
    numSampPerPeriod,
    numSampPerPeriod*params["acqNumSubperiods"],
    params["acqNumFrames"],
    params["acqNumBGFrames"],
    acqFramePeriod,
    params["acqNumAverages"],
    params["acqNumFrameAverages"],
    params["acqNumSubperiods"],
    params["acqNumPeriodsPerPatch"],
    sinLUT,
    cosLUT,
    params["acqNumFFChannels"],
    reshape(params["acqFFValues"],params["acqNumFFChannels"],:),
    reshape(params["acqEnableSequence"],params["acqNumFFChannels"],:),
    reshape(params["calibIntToVolt"],2,:),
    params["calibRefToField"],
    params["calibFieldToVolt"],
    params["calibFFCurrentToVolt"],
    params["currTx"],
    params["controlPause"],
    params["controlLoopAmplitudeAccuracy"],
    params["controlLoopPhaseAccuracy"],
    params["correctCrossCoupling"],
    params["rxChanIdx"],
    params["refChanIdx"],
    params["dfChanIdx"],
    params["txLimitVolt"],
    params["txOffsetVolt"],
    params["controlPhase"],
    params["acqFFSequence"],
    params["ffRampUpTime"],
    params["ffRampUpFraction"],
    params["triggerMode"],
    params["passPDMToFastDAC"]
   )

  return params
end

function MPIFiles.toDict(p::DAQParams)
  params= Dict{String,Any}()

  params["decimation"] = p.decimation
  params["dfBaseFrequency"] = p.dfBaseFrequency
  params["dfDivider"] = p.dfDivider
  params["dfFreq"] = p.dfFreq
  params["dfStrength"] = p.dfStrength
  params["dfPhase"] = p.dfPhase
  params["dfCycle"] = p.dfCycle
  params["dfWaveform"] = p.dfWaveform
  params["jumpSharpness"] = p.jumpSharpness
  params["rxBandwidth"] = p.rxBandwidth
  params["acqNumPeriodsPerFrame"] = p.acqNumPeriodsPerFrame
  params["numSampPerPeriod"] = p.numSampPerPeriod
  params["rxNumSamplingPoints"] = p.rxNumSamplingPoints
  params["acqNumFrames"] = p.acqNumFrames
  params["acqNumBGFrames"] = p.acqNumBGFrames
  params["acqNumSubperiods"] = p.acqNumSubperiods
  params["acqNumPeriodsPerPatch"] = p.acqNumPeriodsPerPatch
  params["acqFramePeriod"] = p.acqFramePeriod
  params["acqNumAverages"] = p.acqNumAverages
  params["acqNumFrameAverages"] = p.acqNumFrameAverages
  params["acqNumFFChannels"] = p.acqNumFFChannels
  params["acqFFValues"] = p.acqFFValues
  params["acqEnableSequence"] = p.acqEnableSequence
  params["calibIntToVolt"] = vec(p.calibIntToVolt)
  params["calibRefToField"] = p.calibRefToField
  params["calibFFCurrentToVolt"] = p.calibFFCurrentToVolt
  params["currTx"] = p.currTx
  params["controlPause"] = p.controlPause
  params["controlLoopAmplitudeAccuracy"] = p.controlLoopAmplitudeAccuracy
  params["controlLoopPhaseAccuracy"] = p.controlLoopPhaseAccuracy
  params["correctCrossCoupling"] = p.correctCrossCoupling
  params["calibFieldToVolt"] = p.calibFieldToVolt
  params["rxChanIdx"] = p.rxChanIdx
  params["refChanIdx"] = p.refChanIdx
  params["dfChanIdx"] = p.dfChanIdx
  params["txLimitVolt"] = p.txLimitVolt
  params["txOffsetVolt"] = p.txOffsetVolt
  params["controlPhase"] = p.controlPhase
  params["acqFFSequence"] = p.acqFFSequence
  params["ffRampUpTime"] = p.ffRampUpTime
  params["ffRampUpFraction"] = p.ffRampUpFraction
  params["triggerMode"] = p.triggerMode
  params["passPDMToFastDAC"] = p.passPDMToFastDAC

  return params
end
